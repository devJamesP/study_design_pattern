안전성 vs 투명성
컴포지트 패턴을 배웠을 때, 복합 객체(Menu)와 잎 노드(MenuItem)에 똑같은 메소드들이 들어있었다.
심지어 add() 메소드도 똑같이 들어있었다. 똑같은 메소드들을 억지로 집어넣다 보니
MenuItem 객체에서 전혀 쓸모없는 메소드까지 집어넣어야 했다.
이렇게 하면 잎과 복합 객체 사이의 차이점을 투명하게 만들 수 있다는 장점이 있다. 클라이언트에서는 잎 노드를 다루고 있는지,
아니면 복합 객체를 다루고 있는지에 대해서 전혀 신경 쓸 필요가 없다. 그냥 무조건 같은 메소드를 호출하면 된다.

여기서는 복합 객체에서 자식을 관리하기 위한 메소드를 복합 객체에만 집어넣었다. add() 메소드는 Flock 클래스에만 있다.
어차피 duck 객체에서는 ad()가 아무 쓸 모 없는 메소드이다. 여기에서 아예 오리에 대해서는 add9) 메소드를 호출할 수가 없다.
Flock에 대해서만 호출 할 수 있다. 이런 디자인은 더 안전하지만 대신 투명성을 떨어진다.
클라이언트에서 어떤 객체에 Quackable을 추가하려면 그 객체가 Flock인지 아닌지를 확실하게 알아야 한다.
언제나 그렇듯이 객체지향 디자인을 할 때는 장점과 단점을 잘 따져봐야 한다. 복합 객체를 만들 때도 상황에 따라서
안정성과 투명성을 적당히 조절해야 한다.